//
// ModelQueryTest.swift
//
// TigaseSQLite3.swift
// Copyright (C) 2020 "Tigase, Inc." <office@tigase.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. Look for COPYING file in the top folder.
// If not, see http://www.gnu.org/licenses/.
//
//

import Foundation

import Foundation
import XCTest
import TigaseSQLite3
import TigaseSQLite3Macros

struct Options: Codable {
    let test: String;
}

enum TestEnum: Int, IntRawRepresentable, Codable {
    case value0 = 0
    case value1 = 1
}

@Entity
final class Test1: SQLCodable, CustomDebugStringConvertible {
    
//    static func fetchRelations(database: DatabaseReader, for items: inout [Test1]) throws {
////        let relations = try Test1.loadRelations(from: database, for: items);
////        let newItems = items.map({ item -> Test1 in
////            item.attachments = relations["attachemts"]?[item.id] as? [TestAttachment] ?? [];
////            return item;
////        });
//        let attachments: [TestAttachment] = try database.select(where: .literal("test_id IN (\(items.map(\.id).map({ $0.description }).joined(separator: ", ")))"));
//        let dictionary = Dictionary(uniqueKeysWithValues: items.map({ ($0.id, $0) }))
//        for attachment in attachments {
//            if let item = dictionary[attachment.testId] {
//                var atts = item.attachments
//                atts.append(attachment);
//                item.attachments = atts;
//            }
//        }
//    }

    var debugDescription: String {
        "Test1(id: \(id), name: \(name), details: \(details), options: \(options), data: \(data), attachments: \(attachments.map({ $0.debugDescription }))"
    }
    
    
//    static let fields: [SQLField<Test1>] = [
//        .init(\.id, column: "id"),
//        .init(\.name, column: "name"),
//        .init(\.details, column: "details"),
//        .init(\.e1, column: "e1"),
//        .init(\.options, column: "options"),
//        .init(\.list, column: "list"),
//        .init(\.createdAt, column: "createdAt"),
//        .init(\.data, column: "data")
//    ]
//    
    static let tableName = "test_1"
    
    required init() {
        id = -1;
        name = "";
        details = nil
        e1 = nil
        options = nil;
        list = nil;
        createdAt = nil
        data = nil
    }
    
    @Autogenerated
    @PrimaryKey
    @Column
    let id: Int;
    @Column
    var name: String;
    @Column
    var details: String?;
    @Column
    var e1: TestEnum?;
    @Column
    var options: Options?;
    @Column
    var list: [String]?;
    @Column
    var createdAt: Date?
    @Column
    var data: Data?
    @Relation("testId")
    var attachments: [TestAttachment] = [];
}

@Entity
public final class TestAttachment: SQLCodable, CustomDebugStringConvertible {
    
    public static let tableName = "test_attachments";
    
//    static let fields: [SQLField<TestAttachment>] = [
//        .field(\.id, column: "id"),
//        .field(\.testId, column: "test_id"),
//        .field(\.path, column: "path")
//    ]
    
    public var debugDescription: String {
        "Attachment(id: \(id), path: \(path))";
    }
    @Autogenerated
    @PrimaryKey
    @Column
    let id: Int;
    @Column("test_id")
    var testId: Int;
    @Column
    var path: URL?;
    
    init() {
        id = 0;
        testId = 0;
        path = nil;
    }
    
}

import Combine

class ModelQueryTest: XCTestCase {
    
    var databasePool: DatabasePool?;
    var cancellable: AnyCancellable?;
    
    override func setUpWithError() throws {
        try databasePool = DatabasePool(configuration: Configuration(path: "file:test.sqlite3"));
        try databasePool?.writer({ database in
            try? database.execute("drop table test_1");
            try? database.execute("drop table test_attachments");
            try database.execute("create table test_1(id integer primary key asc, name text, details text, e1 int, options text, list text, createdAt int, data blob)");
            try database.execute("create table test_attachments(id integer primary key asc, test_id int not null, path text)");
        })
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        try databasePool?.execute("drop table test_1");
        databasePool = nil;
    }
//
//    func test() throws {
//        var data = Test1.FieldTypes.data.init();
//        print("x: \(data.description)");
//        var name = Test1.FieldTypes.name.init();
//        print("x: \(name.description)");
//        var date = Test1.FieldTypes.createdAt.now;
//        print("x: \(date.description)");
//
////        print("columns: \(Schema.shared.columns(for: Test1.self))")
////        print(try Test1.sqlQuery([.equals(\.id, value: 1),.equals(\.name, value: "Test")]))
////        print(try Test1.sqlQuery([\.id, \.name], [.equals(\.id, value: 1),.equals(\.name, value: "Test")]))
//    }
//
    func tests(x: (String)->Bool) {
        
    }
    
    func test2() throws {

        try databasePool?.insert("insert into test_1 (id, name) values (1, 'test1')", params: [])
        try Test1(name: "test2").insert(into: databasePool!);
        var duper = "test"
        let update = #Update<Test1>{ x in
            x.name = "Test123";
            x.createdAt = .now;
        };
        try databasePool!.update(Test1.self, set: update, where: .equals(\.id, value: 1));
        try Test1.update(in: databasePool!, set: #Update<Test1>{ x in
            x.name = "Test123";
            x.createdAt = .now;
        }, where: .equals(\.id, value: 1))
        try Test1.insert(into: databasePool!, name: "test3", e1: .value1, options: Options(test: "Ala ma kota"), list: ["test-1", "test-2"], createdAt: .now, data: Data(repeating: 1, count: 4));
        try databasePool!.insert(TestAttachment.self, values: [.value(\.testId, value: 2), .value(\.path, value: URL(string: "https://www.onet.pl")!)]);
        
        // inserts completed!
        print(try databasePool!.select(from: Test1.self, where: .equals(\.id, value: 1)).first?["name"]);
        print(try databasePool!.select(from: Test1.self, where: .equals(\.id, value: 1)).first![\Test1.id])
        var rows: [ModelRow<Test1>] = try databasePool!.select(where: .and(.equals(\.id, value: 1),.equals(\.id, value: 2)));
        print(rows.map({ $0[\.id] }))
        rows = try databasePool!.select(where: .or(.equals(\.id, value: 1),.equals(\.id, value: 3)));
        print(rows.map({ $0 }))
        print(rows.first == rows.last)
        print(rows.last?[\.createdAt])
        print(rows.last?[\.data])
        print(rows.last?[\.e1])
        print(rows.last?[\.list]?.first)
        var tests = try databasePool!.select(from: Test1.self);
        print(tests)
        tests = try databasePool!.select(from: Test1.self, orderBy: [.ascending(\.name)], limit: .limit(1));
        print(tests)
        var tests1 = try databasePool!.selectFirst(from: Test1.self, orderBy: [.descending(\.name)]);
        print(tests1)
        
        tests = try Test1.select(from: databasePool!, where: #Query<Test1>{ x -> Bool in
            return (x.createdAt! < .now && x.name == "test") && x.name == "ALA"
        })
        tests = try Test1.select(from: databasePool!, where: #Query<Test1>{ ($0.createdAt! < .now && $0.name == "test") && $0.name == "ALA" })
        print("query: ", tests)
//
        let live = LiveQueryWithRelation(database: databasePool!, from: Test1.self, where: nil, orderBy: [.ascending(\.name)]);
        cancellable = live.$results.sink(receiveValue: { values in
            print("values changed: ", values);
        })
        
        print("removing...")
        try databasePool!.delete(Test1.self, where: .equals(\.id, value: 1));
        print("removed!")
        var testsx: [Test1] = try databasePool!.selectWithRelations();
        print("with:", testsx)
        try databasePool!.insert(TestAttachment.self, values: [.value(\.testId, value: 3), .value(\.path, value: URL(string: "https://www.wp.pl"))]);
        print("\nsleeping..");
        try databasePool!.withTransaction({
            for i in 1...10 {
                try Test1.insert(into: $0, name: "Test \(i)")
            }
        })
        sleep(1);
    }
}
